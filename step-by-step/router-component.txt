* router-component.js

Questo file Ã¨ il cuore della navigazione dellâ€™intera applicazione.
Il professore ha costruito un miniâ€‘router in stile SPA (Single Page Application) usando solo JavaScript vanilla e gli hash dellâ€™URL.


ğŸ§© 1. Definizione del componente

class RouterComponent extends HTMLElement 

Stai creando un nuovo custom element <router-component>.
Questo elemento sarÃ  responsabile di decidere quale pagina mostrare.

--------------------------------------------------------------------------------------------------------------------------------------------

ğŸ§± 2. Costruttore

constructor() {
    super();
    this.shadow = this.attachShadow({ mode: 'open' });
}

- super() richiama il costruttore di HTMLElement.
- attachShadow() crea lo Shadow DOM, cosÃ¬ il contenuto del router non interferisce con il resto della pagina.

--------------------------------------------------------------------------------------------------------------------------------------------------

âš¡ 3. connectedCallback()

connectedCallback() {

    this.updateRoute();

    window.addEventListener('hashchange', () => this.updateRoute());
}

Questo metodo viene eseguito quando <router-component> viene inserito nella pagina.

Fa due cose fondamentali:

âœ”ï¸ 1. Chiama updateRoute() subito
Serve per mostrare la pagina corretta appena il componente viene caricato.

âœ”ï¸ 2. Ascolta i cambiamenti dellâ€™hash nellâ€™URL
window.addEventListener('hashchange', ...)

Ogni volta che lâ€™URL cambia da:

#/home
#/about
#/contact

il router aggiorna la vista.

------------------------------------------------------------------------------------------------------------------------------

ğŸ§­ 4. updateRoute()

Questo Ã¨ il cuore del router.

const route = window.location.hash.slice(1) || 'home';

Cosa fa?

  -  window.location.hash â†’ es. "#about"

  - .slice(1) â†’ rimuove il #, ottenendo "about"

  -  Se non câ€™Ã¨ hash â†’ usa "home" come default

Quindi route sarÃ  sempre una di queste:

  -  "home"

  - "about"

  - "contact"

    oppure qualunque altra stringa (che porterÃ  a â€œPage not foundâ€)


ğŸ”€ 4.1 Routing vero e proprio

if (route === 'home') {
    this.shadow.innerHTML = `<super-home></super-home>`;
} else if (route === 'about') {
    this.shadow.innerHTML = `<super-about></super-about>`;
} else if (route === 'contact') {
    this.shadow.innerHTML = `<super-contact></super-contact>`;
} else {
    this.shadow.innerHTML = `<p>Page not found</p>`;
}

Come funziona?

  -  Se lâ€™URL contiene #/home â†’ mostra <super-home>

  -  Se contiene #/about â†’ mostra <super-about>

  -  Se contiene #/contact â†’ mostra <super-contact>

  -  Altrimenti â†’ mostra un messaggio di errore

In pratica, il router sostituisce dinamicamente il contenuto del suo shadow DOM con il componente corretto.


-----------------------------------------------------------------------------------------------------------------------------------------------

ğŸ·ï¸ 5. Registrazione del custom element

customElements.define('router-component', RouterComponent);

Da questo momento puoi usare:

<router-component></router-component>

e il router funzionerÃ  automaticamente.

----------------------------------------------------------------------------------------------------------------------------------------------------

ğŸ“Œ Riassunto finale
Parte	               Funzione
connectedCallback()	   Inizializza il router e ascolta i cambiamenti dellâ€™URL
updateRoute()	       Decide quale componente mostrare
Hash routing	       Usa #/qualcosa per cambiare pagina senza ricaricare
Shadow DOM	           Isola il contenuto del router